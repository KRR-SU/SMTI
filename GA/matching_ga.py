# -*- coding: utf-8 -*-
"""matching_GA_düzeltme.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/119BMp57yOZbnogND0-Lxl1kHByVRnccz
"""

# -*- coding: utf-8 -*-
"""Matching_GA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j2hZdKZ_UVhFutqVpXXeKM-QVeULRcWs
"""

"""
Genetic Algorithm implementation based on paper "Two‐Sided Matching with Indifferences: Using Heuristics to Improve Properties of Stable Matchings" by Christian Haas 
İlayda Begüm İzci-09.12.2020
"""
import random
import numpy as np
import bisect
import time
import sys


def randomTieBreaker(preferenceList):
    newPreferenceList = []
    for agent in preferenceList:
        if type(agent) is tuple:
            for person in random.sample(agent, len(agent)):
                newPreferenceList.append(person)
        else:
            newPreferenceList.append(agent)
    # added for Gale-Shapley algorithm to work with incomplete preferences
    newPreferenceList.append(-1)
    return newPreferenceList


def prefBreakTies(menPref, womenPref):
    manNewPref = {}
    womanNewPref = {}
    for man, manPreferenceList in menPref.items():
        manNewPref[man] = randomTieBreaker(manPreferenceList)
    for woman, womanPreferenceList in womenPref.items():
        womanNewPref[woman] = randomTieBreaker(womanPreferenceList)
    return manNewPref, womanNewPref


def DA(n, preferenceDict1, preferenceDict2):
    unMatched = list(range(1, n + 1))
    menMatch = [None] * n
    womenMatch = [-1] * n
    menProposeOrder = [0] * n
    while unMatched:
        man = unMatched[0]
        preferencesMan = preferenceDict1[man]
        woman = preferencesMan[menProposeOrder[man - 1]]
        if woman == -1:
            menMatch[man - 1] = woman
            unMatched.pop(0)
        else:
            preferencesWoman = preferenceDict2[woman]
            currentMatch = womenMatch[woman - 1]
            if currentMatch == -1:
                womenMatch[woman - 1] = man
                menMatch[man - 1] = woman
                menProposeOrder[man - 1] += 1
                unMatched.pop(0)
            else:
                currentIndex = preferencesWoman.index(currentMatch)
                hisIndex = preferencesWoman.index(man)
                if currentIndex > hisIndex:
                    womenMatch[woman - 1] = man
                    menMatch[man - 1] = woman
                    menProposeOrder[man - 1] += 1
                    unMatched.pop(0)
                    unMatched.insert(0, currentMatch)
                else:
                    menProposeOrder[man - 1] += 1
    matching_returned = list(zip(list(range(1, n + 1)), menMatch))
    for woman in np.where(np.array(womenMatch) == -1)[0].tolist():
        matching_returned.append((-1, woman + 1))
    return matching_returned


def find_index(a_list, s):
    # if s is -1 return the length so that to find blocking pairs all the pref_list will be scanned in findblockingpairs function
    if s == -1:
        return len(a_list)
    if s in a_list:
        return a_list.index(s)
    else:
        for el in a_list:
            if isinstance(el, tuple):
                if s in el:
                    return a_list.index(el)
    return -1


"""
  step1 population initialized, /
  step2 cycle_crossover_operator /
  step3 mutation_operator /
  step4 select function /
  step5 isStable /
  step6 fitness function /
  step7 experiment
  step8 timeout 
"""


def init_population(pop_number, preferencesMan, preferencesWoman):
    population = []
    for i in range(pop_number):
        manNewPref, womanNewPref = prefBreakTies(preferencesMan, preferencesWoman)
        new_individual = DA(len(manNewPref), manNewPref,
                            womanNewPref)  # [gene_pool[random.randrange(0, g)] for j in range(state_length)]
        # print(new_individual)
        population.append(new_individual)
    return population


def weighted_sampler(seq, weights):
    """Return a random-sample function that picks from seq weighted by weights."""
    totals = []
    for w in weights:
        totals.append(w + totals[-1] if totals else w)
    return lambda: seq[bisect.bisect(totals, random.uniform(0, totals[-1]))]


def select(r, population, fitness_fn, mpref, wpref):
    fitnesses = map(lambda s: fitness_fn(s, mpref, wpref), population)
    sampler = weighted_sampler(population, fitnesses)
    return [sampler() for i in range(r)]


def numberBP(matching, men_pref, women_pref):
    unzipped = list(zip(*matching))
    matched_men = list(unzipped[0])
    matched_women = list(unzipped[1])
    num_BP = 0
    for man in men_pref.keys():
        # index of the current match
        index = find_index(men_pref[man], matched_women[matched_men.index(man)])
        # if woman is not in the list ??burayı tutmalı mıyım
        if index == -1:
            index = len(men_pref[man])
        for ind in range(index):
            woman = men_pref[man][ind]
            if isinstance(woman, tuple):  # if there is a tie
                for wom in woman:
                    my_rank = find_index(women_pref[wom], man)
                    currentP_rank = find_index(women_pref[wom], matched_men[matched_women.index(wom)])
                    if currentP_rank > my_rank:
                        num_BP += 1
            else:
                my_rank = find_index(women_pref[woman], man)
                currentP_rank = find_index(women_pref[woman], matched_men[matched_women.index(woman)])
                if currentP_rank > my_rank:
                    num_BP += 1
    return num_BP


def isStable(matching, men_pref, women_pref):
    unzipped = list(zip(*matching))
    matched_men = list(unzipped[0])
    matched_women = list(unzipped[1])
    # print(matched_men,matched_women)
    num_BP = 0
    try:
        for man in men_pref.keys():
            # index of the current match
            index = find_index(men_pref[man], matched_women[matched_men.index(man)])
            # if woman is not in the list ??burayı tutmalı mıyım
            if index == -1:
                index = len(men_pref[man])
            for ind in range(index):
                woman = men_pref[man][ind]
                if isinstance(woman, tuple):  # if there is a tie
                    for wom in woman:
                        my_rank = find_index(women_pref[wom], man)
                        currentP_rank = find_index(women_pref[wom], matched_men[matched_women.index(wom)])
                        if currentP_rank > my_rank:
                            return False
                else:
                    my_rank = find_index(women_pref[woman], man)
                    currentP_rank = find_index(women_pref[woman], matched_men[matched_women.index(woman)])
                    if currentP_rank > my_rank:
                        return False
        return True
    except:
        return False


def find_cycles(x, y, start, size):
    found = False
    woman_x = [t[1] for t in x]
    woman_y = [k[1] for k in y]
    a = woman_x[start]
    b = woman_y[start]
    count = 1
    while a == b:
        if count > size:
            return x, y
        start = (start + count) % size
        count += 1
        a = woman_x[start]
        b = woman_y[start]
    cyc_list = [(start, start)]
    sT2 = size
    visited_singleMx = []
    count = 0

    while not found:
        try:
            ind = woman_x.index(b)
        except:
            return x, y
        if b == -1: #single men
            if ind in visited_singleMx:
                if b in woman_x[visited_singleMx[-1] + 1:]:
                    ind = woman_x.index(b, visited_singleMx[-1] + 1)
                    count += 1
                    if count > 20:
                        return x, y

                else:
                    return x, y
            else:
                visited_singleMx.append(ind)
        if ind >= size:  # single woman
            if sT2 >= len(woman_y):
                return x, y
            b = woman_y[sT2]  # singl woman next in line
            cyc_list.append((ind, sT2))
            sT2 += 1
        else:
            b = woman_y[ind]
            cyc_list.append((ind, ind))
        if b == a:
            found = True
    newX = list.copy(x)
    newY = list.copy(y)
    for swapI in cyc_list:
        newX[swapI[0]] = y[swapI[1]]
        newY[swapI[1]] = x[swapI[0]]
    return newX, newY


def cycle_crossover_operator(x, y, pref1, pref2):
    r = random.randrange(0, len(pref1))
    newx, newy = find_cycles(x, y, r, len(pref1))
    if newx != x and newy != y:
        if isStable(newx, pref1, pref2) and isStable(newy, pref1, pref2):
            found = True
            return newx, newy
    return x, y


def createGraph(match, mpref, wpref):
    graph = {i: [] for i in range(len(match))}
    for m in range(len(match)):  # m is index of the match
        m1 = match[m][0]
        w1 = match[m][1]
        if w1 == -1:
            for n in range(len(match)):
                if match[n][0] == -1:
                    graph[m].append(n)
        else:
            rank1w = find_index(wpref[w1], m1)
            for n in range(len(match)):
                if n != m:
                    m2 = match[n][0]
                    w2 = match[n][1]
                    if m2 != -1:
                        rank2m = find_index(mpref[m2], w2)
                        rank3w = find_index(wpref[w1], m2)
                        rank3m = find_index(mpref[m2], w1)
                        if rank1w >= rank3w:
                            if rank2m >= rank3m:
                                if find_index(wpref[w1], m2) != -1:
                                    graph[m].append(n)
    return graph


# finds shortest path between 2 nodes of a graph using BFS
def bfs_shortest_path(graph, start, goal):
    # keep track of explored nodes
    explored = []
    # keep track of all the paths to be checked
    queue = [[start]]
    # keeps looping until all possible paths have been checked
    while queue:
        # pop the first path from the queue
        path = queue.pop(0)
        # get the last node from the path
        node = path[-1]
        if node not in explored:
            neighbours = graph[node]
            # go through all neighbour nodes, construct a new path and
            # push it into the queue
            for neighbour in neighbours:
                new_path = list(path)
                new_path.append(neighbour)
                queue.append(new_path)
                # return path if neighbour is goal
                if neighbour == goal:
                    return new_path

            # mark node as explored
            explored.append(node)

    # in case there's no path between the 2 nodes
    return 0


def mutation_operator(x, pmut, mpref, wpref):
    if random.uniform(0, 1) >= pmut:
        return x
    graph = createGraph(x, mpref, wpref)
    look_circle = [y for y in range(len(x)) if x[y][0] == -1]
    for m in look_circle + list(range(len(x))):
        path = bfs_shortest_path(graph, m, m)
        if path != 0:
            break
    if path != 0:
        n = -1
        for ind in path:
            p = n
            n = x[ind][1]
            x[ind] = (x[ind][0], p)
        if (-1, -1) in x:
            x.remove((-1, -1))
    return x


# fitness_fn evaluates number of blocking pair plus number of singles, returns negative of this number because we actually minimize this value
def fitness_fn(sample, preferencesMenF, preferencesWomenF):
    # initialize fitness to 0
    # fitness = numberBP(sample,preferencesMenF, preferencesWomenF)
    # fitness += len(sample)-len(preferencesMenF)
    return 2 * len(preferencesMenF) - len(sample)  # number of matchings


def fitness_threshold(fitness_fn, f_thres, population, preferencesMenF, preferencesWomenF):
    if not f_thres:
        return None
    fittest_individual = max(population, key=lambda s: fitness_fn(s, preferencesMenF, preferencesWomenF))
    if fitness_fn(fittest_individual, preferencesMenF, preferencesWomenF) >= f_thres:
        return fittest_individual
    return None


# ngen ->max number of generations -- number of iterations
# pmut=probability of mutation
def genetic_algorithm_stepwise(population, fitness_fn, mpref, wpref, f_thres=None, ngen=1000, pmut=0.2):
    fittest_individual = fitness_threshold(fitness_fn, f_thres, population, mpref, wpref)
    totaltime = 0
    overall_best = [0, 0]
    # if fitness is greater than or equal to f_thres, we terminate the algorithm
    if fittest_individual:
        return fittest_individual, 1
    for generation in range(ngen):
        loopS = time.time()
        newpop = []
        for i in range(len(population) // 2):
            newKids = cycle_crossover_operator(*select(2, population, fitness_fn, mpref, wpref), mpref, wpref)
            newpop.append(mutation_operator(newKids[0], pmut, mpref, wpref))
            newpop.append(mutation_operator(newKids[1], pmut, mpref, wpref))
        population = newpop
        # print("current pop",population)

        # stores the individual genome with the highest fitness in the current population
        current_best = max(population, key=lambda s: fitness_fn(s, mpref, wpref))
        # print("iteration",generation,"match val",fitness_fn(current_best,mpref,wpref))
        if fitness_fn(current_best, mpref, wpref) > overall_best[0]:
            overall_best[0] = fitness_fn(current_best, mpref, wpref)
            overall_best[1] = current_best
        # compare the fitness of the current best individual to f_thres
        fittest_individual = fitness_threshold(fitness_fn, f_thres, population, mpref, wpref)

        # if fitness is greater than or equal to f_thres, we terminate the algorithm
        if fittest_individual:
            return fittest_individual, generation
        loopE = time.time()
        totaltime += loopE - loopS
        if totaltime > 1990:
            break
    return max(population, key=lambda s: fitness_fn(s, mpref, wpref)), ngen


def main():
    # Read from file
    inputF = ""
    if len(sys.argv) == 1:  # in this case there is only sys.argv[0] which the is the name of the python file
        print("No file name supplied! Program will exit!")
        exit()
    else:
        inputF = sys.argv[1]

    with open(inputF) as fp:
        lines = fp.readlines()
    mensize = int(lines[1])
    womensize = int(lines[2])
    menprefDict = {key: [] for key in range(1, int(mensize) + 1)}
    womenprefDict = {key: [] for key in range(1, int(womensize) + 1)}
    for line in lines[3:int(mensize) + 3]:
        preferencesM = line.split()
        tupl = []
        for p in range(1, len(preferencesM)):
            if '(' in preferencesM[p] and ')' in preferencesM[p]:
                menprefDict[int(preferencesM[0])].append(int(preferencesM[p][1:-1]))
            elif ')' in preferencesM[p]:
                tupl.append(int(preferencesM[p][:-1]))
                menprefDict[int(preferencesM[0])].append(tuple(tupl))
                tupl = []
            else:
                if '(' in preferencesM[p]:
                    tupl.append(int(preferencesM[p][1:]))
                else:
                    tupl.append(int(preferencesM[p]))

    for line in lines[int(mensize) + 3:]:
        preferencesW = line.split()
        tupl = []
        for p in range(1, len(preferencesW)):
            if '(' in preferencesW[p] and ')' in preferencesW[p]:
                womenprefDict[int(preferencesW[0])].append(int(preferencesW[p][1:-1]))
            elif ')' in preferencesW[p]:
                tupl.append(int(preferencesW[p][:-1]))
                womenprefDict[int(preferencesW[0])].append(tuple(tupl))
                tupl = []
            else:
                if '(' in preferencesW[p]:
                    tupl.append(int(preferencesW[p][1:]))
                else:
                    tupl.append(int(preferencesW[p]))

    population_size = 50
    sTime = time.time()
    bestMatching, generation = genetic_algorithm_stepwise(init_population(population_size, menprefDict, womenprefDict),
                                                          fitness_fn, menprefDict, womenprefDict, len(menprefDict), 1000,
                                                          0.2)
    eTime = time.time()
    timePassed = eTime - sTime

    print("%s" % ("Run time: " + str(timePassed)))
    print("Number of steps: " + str(generation))
    print("%s" % ("Number of singles: " + str(2 * (len(bestMatching) - len(menprefDict)))))

    print("\nSolution:")
    for pair in bestMatching:
        print("%s" % str(pair))


if __name__ == "__main__":
    main()
